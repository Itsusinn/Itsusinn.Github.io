[{"content":"创建顶级Btrfs子卷 1 2 3 4 5 $ fdisk -l $ sudo mount /dev/\u0026lt;part\u0026gt; -o subvolid=5 /mnt $ cd /mnt $ sudo btrfs subvolume create \u0026lt;name\u0026gt; $ sudo btrfs subvolume list / : Btrfs分区名 : 子卷名称\n挂载Btrfs子卷 1 mount -t btrfs -o subvol=[volname]，defaults,compress=zstd /dev/disk/by-uuid/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX /path/to/mount 挂载Btrfs子卷为交换区 1 2 3 4 5 6 7 8 9 10 11 $ sudo vim /etc/fstab UUID=\u0026lt;UUID\u0026gt; /swap btrfs subvol=/\u0026lt;name\u0026gt;,defaults 0 0 /swap/swapfile swap swap defaults 0 0 $ cd / $ sudo mkdir swap $ sudo mount -a $ sudo btrfs filesystem mkswapfile --size 8g --uuid clear /swap/swapfile $ sudo swapon /swap/swapfile $ sudo mount -a : Btrfs分区UUID\n: 子卷名称\nDocker UFW 如果希望允许外部网络访问 Docker 容器提供的服务，比如有一个容器的服务端口是 80。那就可以用以下命令来允许外部网络访问这个服务：\nufw route allow proto tcp from any to any port 80\n这个命令会允许外部网络访问所有用 Docker 发布出来的并且内部服务端口为 80 的所有服务。\nBtrfs \u0026amp; RefindEFI /boot/refind_linux\n1 \u0026#34;Boot using standard options\u0026#34; \u0026#34;root=PARTUUID=9255bf76-e8da-45be-9a61-4fdc63cfea7d rw rootflags=subvol=arch initrd=arch\\boot\\amd-ucode.img initrd=arch\\boot\\initramfs-%v.img\u0026#34; FFMPEG 将所有wmv转为MP4 1 2 3 4 for files in $(ls *.wmv) do ffmpeg -i $files -c:v libx264 -crf 23 -c:a aac -q:a 100 ${files%%.*}.mp4 done encode the video to H.264 video and AAC audio, using the default quality\n","date":"2023-08-27T21:55:07+08:00","permalink":"https://itsusinn.github.io/p/linux-tips/","title":"Linux Tips"},{"content":"Java标准库中的SecureRandom提供了一个密码学意义上的强随机数生成器。作为一个程序员，如果我们在JVM里出于安全考虑，想获取一个“真正随机”的数字，则很有可能将SecureRandom纳入考虑范围之内。 然而使用它需要十分的小心。\n对SecureRandom起兴趣是因为一次对网络程序的排错，账号的登录过程十分缓慢。日志十分正常，没有任何警告或者错误。所以最初怀疑是某种逻辑错误导致的死循环。\njstack的thread dump如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026#34;main\u0026#34; #1 prio=5 os_prio=0 cpu=2745.71ms elapsed=56.22s tid=0x00007f2ec4014800 nid=0x2494 runnable [0x00007f2ecde32000] java.lang.Thread.State: RUNNABLE at java.io.FileInputStream.readBytes(java.base@11.0.9.1/Native Method) at java.io.FileInputStream.read(java.base@11.0.9.1/FileInputStream.java:279) at java.io.FilterInputStream.read(java.base@11.0.9.1/FilterInputStream.java:133) at sun.security.provider.NativePRNG$RandomIO.readFully(java.base@11.0.9.1/NativePRNG.java:424) at sun.security.provider.NativePRNG$RandomIO.implGenerateSeed(java.base@11.0.9.1/NativePRNG.java:441) - locked \u0026lt;0x00000000ed00c680\u0026gt; (a java.lang.Object) at sun.security.provider.NativePRNG.engineGenerateSeed(java.base@11.0.9.1/NativePRNG.java:226) at java.security.SecureRandom.generateSeed(java.base@11.0.9.1/SecureRandom.java:857) at java.security.SecureRandom.getSeed(java.base@11.0.9.1/SecureRandom.java:840) at net.mamoe.mirai.internal.network.protocol.packet.login.wtlogin.WtLogin15Kt.get_mpasswd(WtLogin15.kt:136) at net.mamoe.mirai.internal.network.QQAndroidClient.\u0026lt;init\u0026gt;(QQAndroidClient.kt:268) at net.mamoe.mirai.internal.network.QQAndroidClient.\u0026lt;init\u0026gt;(QQAndroidClient.kt:72) at net.mamoe.mirai.internal.QQAndroidBot.initClient(QQAndroidBot.kt:62) at net.mamoe.mirai.internal.QQAndroidBot.\u0026lt;init\u0026gt;(QQAndroidBot.kt:59) at net.mamoe.mirai.internal.BotFactoryImpl.newBot(BotFactory.kt:34) at net.mamoe.mirai.BotFactory$INSTANCE.newBot(BotFactory.kt:115) at net.mamoe.mirai.console.MiraiConsole$INSTANCE.addBotImpl(MiraiConsole.kt:163) at net.mamoe.mirai.console.MiraiConsole$INSTANCE.addBot(MiraiConsole.kt:125) at net.mamoe.mirai.console.internal.MiraiConsoleImplementationBridge$doStart$11$1.invokeSuspend(MiraiConsoleImplementationBridge.kt:241) at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33) at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:106) at kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:274) at kotlinx.coroutines.BlockingCoroutine.joinBlocking(Builders.kt:86) at kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking(Builders.kt:61) at kotlinx.coroutines.BuildersKt.runBlocking(Unknown Source) at kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking$default(Builders.kt) at kotlinx.coroutines.BuildersKt.runBlocking$default(Unknown Source) at net.mamoe.mirai.console.internal.MiraiConsoleImplementationBridge.doStart$mirai_console(MiraiConsoleImplementationBridge.kt:214) at net.mamoe.mirai.console.MiraiConsoleImplementation$Companion.start(MiraiConsoleImplementation.kt:209) at net.mamoe.mirai.console.terminal.MiraiConsoleTerminalLoader.startAsDaemon(MiraiConsoleTerminalLoader.kt:153) at net.mamoe.mirai.console.terminal.MiraiConsoleTerminalLoader.startAsDaemon$default(MiraiConsoleTerminalLoader.kt:152) at net.mamoe.mirai.console.terminal.MiraiConsoleTerminalLoader.main(MiraiConsoleTerminalLoader.kt:48) Locked ownable synchronizers: - \u0026lt;0x00000000ed5cf040\u0026gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync) 可以看到程序阻塞在了java.security.SecureRandom和java.io.FileInputStream.readBytes。\n看起来我们的 SecureRandom 在读取什么文件？如果你了解类Unix系统的话就不难猜出这个文件是 /dev/random。在GNU Linux上读取 /dev/random 这个设备文件就会得到随机的字节(试试 cat /dev/random?)。Linux系统会借助用户的鼠标输入、键盘输入、硬盘读取等环境噪声生成随机数。Linux将环境噪声保存在熵池中，使用cat /proc/sys/kernel/random/entropy_avail可以查看熵池的大小。显然在服务器环境下这些噪声较为稀少，这就导致了在服务器上 /dev/random 随机数生成缓慢。\n","date":"2023-08-23T00:12:51+08:00","permalink":"https://itsusinn.github.io/p/java-secure-random/","title":"Java Secure Random"}]